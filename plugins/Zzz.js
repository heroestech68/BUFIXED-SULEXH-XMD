const { ezra } = require("../fredi/ezra"); const axios = require("axios"); let { Sticker, createSticker, StickerTypes } = require("wa-sticker-formatter"); const { isUserBanned, addUserToBanList, removeUserFromBanList } = require("../lib/banUser"); const { addGroupToBanList, isGroupBanned, removeGroupFromBanList } = require('../lib/banGroup'); const { isGroupOnlyAdmin, addGroupToOnlyAdminList, removeGroupFromOnlyAdminList } = require('../lib/onlyAdmin'); const { removeSudoNumber, addSudoNumber, issudo } = require("../lib/sudo"); const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));

ezra({ nomCom: "tgs2", categorie: "✧buhfixed sulexh-Mods" }, async (jid, zk, options) => { const { ms, repondre, arg, nomAuteurMessage, superUser } = options; if (!superUser) return repondre("Only bot owner and superusers can use this command"); if (!arg[0]) return repondre("put a telegramme stickers link "); let url = arg.join(" "); let setName = url.split('/addstickers/')[1]; let apiUrl = "https://api.telegram.org/bot891038791:AAHWB1dQd-vi0IbH2NjKYUk-hqQ8rQuzPD4/getStickerSet?name=" + encodeURIComponent(setName); try { let res = await axios.get(apiUrl); let type = (res.data.result.is_animated || res.data.result.is_video) ? "animated sticker" : "not animated sticker"; await repondre(   Zk-stickers-dl\n\n  *Name :* ${res.data.result.name}\n  *Type :* ${type}\n  *Length :* ${res.data.result.stickers.length}\n\nDownloading...); for (let i = 0; i < res.data.result.stickers.length; i++) { let file = await axios.get("https://api.telegram.org/bot891038791:AAHWB1dQd-vi0IbH2NjKYUk-hqQ8rQuzPD4/getFile?file_id=" + res.data.result.stickers[i].file_id); let stickerData = await axios({ method: "get", url: "https://api.telegram.org/file/bot891038791:AAHWB1dQd-vi0IbH2NjKYUk-hqQ8rQuzPD4/" + file.data.result.file_path, responseType: "arraybuffer" }); const sticker = new Sticker(stickerData.data, { pack: nomAuteurMessage, author: "bugfixed sulexh xmd", type: StickerTypes.FULL, categories: ['🤩', '🎉'], id: "12345", quality: 50, background: "#000000" }); const buffer = await sticker.toBuffer(); await zk.sendMessage(jid, { sticker: buffer }, { quoted: ms }); } } catch (e) { repondre("we got an error \n" + e); } });

ezra({ nomCom: "crew2", categorie: "bugfixed sulexh-Mods" }, async (jid, zk, options) => { const { ms, repondre, arg, auteurMessage, superUser, auteurMsgRepondu, msgRepondu } = options; if (!superUser) return repondre("Only bot owner and superusers can use this command"); if (!arg[0]) return repondre("Please enter the name of the group to create"); if (!msgRepondu) return repondre("Please mention a member added "); const name = arg.join(" "); const group = await zk.groupCreate(name, [auteurMessage, auteurMsgRepondu]); zk.sendMessage(group.id, { text: "Bienvenue dans " + name }); });

ezra({ nomCom: "left2", categorie: "bugfixed sulexh-Mods" }, async (jid, zk, options) => { const { repondre, superUser } = options; if (!superUser) return repondre("Only bot owner and superusers can use this command"); await zk.groupLeave(jid); });

ezra({ nomCom: "join2", categorie: "bugfixed sulexh-Mods" }, async (jid, zk, options) => { const { arg, repondre, superUser } = options; if (!superUser) return repondre("Only bot owner and superusers can use this command"); let code = arg[0].split('https://chat.whatsapp.com/')[1]; await zk.groupAcceptInvite(code); repondre("Succes").catch(() => repondre("Unknown error")); });

ezra({ nomCom: "jid2", categorie: "bugfixed sulexh-Mods" }, async (jid, zk, options) => { const { ms, repondre, msgRepondu, superUser, auteurMsgRepondu } = options; if (!superUser) return repondre("Only bot owner and superusers can use this command"); let result = msgRepondu ? auteurMsgRepondu : jid; zk.sendMessage(jid, { text: result }, { quoted: ms }); });

ezra({ nomCom: "block2", categorie: "bugfixed sulexh-Mods" }, async (jid, zk, options) => { const { repondre, msgRepondu, superUser, auteurMsgRepondu } = options; if (!superUser) return repondre("Only bot owner and superusers can use this command"); let target = msgRepondu ? auteurMsgRepondu : jid; await zk.updateBlockStatus(target, "block").then(() => repondre("succes")); });

ezra({ nomCom: "unblock2", categorie: "bugfixed sulexh-Mods" }, async (jid, zk, options) => { const { repondre, msgRepondu, superUser, auteurMsgRepondu } = options; if (!superUser) return repondre("Only bot owner and superusers can use this command"); let target = msgRepondu ? auteurMsgRepondu : jid; await zk.updateBlockStatus(target, "unblock").then(() => repondre("succes")); });

ezra({ nomCom: "kickall2", categorie: "bugfixed sulexh-Group", reaction: '📣' }, async (jid, zk, options) => { const { ms, repondre, verifGroupe, infosGroupe, superUser } = options; if (!verifGroupe) return repondre("✋🏿 ✋🏿this command is reserved for groups ❌"); if (!superUser) return repondre("Only bot owner and superusers can use this command"); repondre("No_admin members will be removed from the group. You have 5 seconds to reclaim your choice by restarting the bot."); await sleep(5000); try { let participants = verifGroupe ? await infosGroupe.participants : []; let toKick = participants.filter(p => !p.admin); for (const u of toKick) { await zk.groupParticipantsUpdate(jid, [u.id], 'remove'); await sleep(500); } } catch { repondre("I need administration rights"); } });

ezra({ nomCom: "ban2", categorie: 'bugfixed sulexh-Mods' }, async (jid, zk, options) => { const { arg, auteurMsgRepondu, msgRepondu, repondre, prefixe, superUser } = options; if (!superUser) return repondre("Only bot owner and superusers can use this command"); if (!arg[0]) return repondre("mention the victim by typing " + prefixe + "ban add/del"); if (msgRepondu) { switch (arg.join(" ")) { case "add": if (await isUserBanned(auteurMsgRepondu)) return repondre("This user is already banned"); addUserToBanList(auteurMsgRepondu); break; case "del": if (await isUserBanned(auteurMsgRepondu)) { removeUserFromBanList(auteurMsgRepondu); repondre("This user is now free."); } else repondre("This user is not banned."); break; default: repondre("bad option"); } } else repondre("mention the victim"); });

ezra({ nomCom: "bangroup2", categorie: "bugfixed sulexh-Mods" }, async (jid, zk, options) => { const { arg, repondre, prefixe, superUser, verifGroupe } = options; if (!superUser) return repondre("Only bot owner and superusers can use this command"); if (!verifGroupe) return repondre("order reservation for groups"); if (!arg[0]) return repondre("type " + prefixe + "bangroup add/del"); const banned = await isGroupBanned(jid); switch (arg.join(" ")) { case 'add': if (banned) return repondre("This group is already banned"); addGroupToBanList(jid); break; case "del": if (banned) { removeGroupFromBanList(jid); repondre("This group is now free."); } else repondre("This group is not banned."); break; default: repondre("bad option"); } });

ezra({ nomCom: "onlyadmin2", categorie: "bugfixed sulexh-Group" }, async (jid, zk, options) => { const { arg, repondre, prefixe, superUser, verifGroupe } = options; if (!superUser) return repondre("Only bot owner and superusers can use this command"); if (!verifGroupe) return repondre("order reservation for groups"); if (!arg[0]) return repondre("type " + prefixe + "onlyadmin add/del"); const onlyAdmin = await isGroupOnlyAdmin(jid); switch (arg.join(" ")) { case 'add': if (onlyAdmin) return repondre("This group is already in onlyadmin mode"); addGroupToOnlyAdminList(jid); break; case "del": if (onlyAdmin) { removeGroupFromOnlyAdminList(jid); repondre("This group is now free."); } else repondre("This group is not in onlyadmin mode."); break; default: repondre("bad option"); } });

ezra({ nomCom: "sudo", categorie: "bugfixed sulexh-Mods" }, async (jid, zk, options) => { const { arg, auteurMsgRepondu, msgRepondu, repondre, prefixe, superUser } = options; if (!superUser) return repondre("Only bot owner and superusers can use this command"); if (!arg[0]) return repondre("mention the person by typing " + prefixe + "sudo add/del"); if (msgRepondu) { switch (arg.join(" ")) { case "add": if (await issudo(auteurMsgRepondu)) return repondre("This user is already sudo"); addSudoNumber(auteurMsgRepondu); repondre("succes"); break; case "del": if (await issudo(auteurMsgRepondu)) { removeSudoNumber(auteurMsgRepondu); repondre("This user is now non-sudo."); } else repondre("This user is not sudo."); break; default: repondre("bad option"); } } else repondre("mention the victim"); });

ezra({ nomCom: "save", categorie: "bugfixed sulexh-Mods" }, async (jid, zk, options) => { const { repondre, msgRepondu, superUser, auteurMessage } = options; if (!superUser) return repondre("Only bot owner and superusers can use this command"); if (!msgRepondu) return repondre("Mention the message that you want to save"); let data; if (msgRepondu.imageMessage) { let file = await zk.downloadAndSaveMediaMessage(msgRepondu.imageMessage); data = { image: { url: file }, caption: msgRepondu.imageMessage.caption }; } else if (msgRepondu.videoMessage) { let file = await zk.downloadAndSaveMediaMessage(msgRepondu.videoMessage); data = { video: { url: file }, caption: msgRepondu.videoMessage.caption }; } else if (msgRepondu.audioMessage) { let file = await zk.downloadAndSaveMediaMessage(msgRepondu.audioMessage); data = { audio: { url: file }, mimetype: 'audio/mp4' }; } else if (msgRepondu.stickerMessage) { let file = await zk.downloadAndSaveMediaMessage(msgRepondu.stickerMessage); let sticker = new Sticker(file, { pack: "bugfixed sulexh", type: StickerTypes.CROPPED, categories: ['🤩', '🎉'], id: "12345", quality: 70, background: "transparent" }); const buffer = await sticker.toBuffer(); data = { sticker: buffer }; } else { data = { text: msgRepondu.conversation }; } zk.sendMessage(auteurMessage, data); });

ezra({ nomCom: "mention", categorie: "bugfixed sulexh-Mods" }, async (jid, zk, options) => { const { repondre, superUser, arg } = options; if (!superUser) return repondre("Only bot owner and superusers can use this command"); const mentionLib = require('../lib/mention'); let allData = await mentionLib.recupererToutesLesValeurs(); let data = allData[0]; if (!arg || arg.length < 1) { if (allData.length === 0) return repondre("To activate or modify the mention; follow this syntax: mention link type message\nThe types are audio, video, image, and sticker."); let status = data.status == "non" ? "Desactived" : "Actived"; let mtype = data.type || "no data"; let url = data.url || "no data"; return repondre(Status: ${status}\nType: ${mtype}\nLink: ${url}); } if (arg.length >= 2) { if (arg[0].startsWith("http") && ["image", "audio", "video", "sticker"].includes(arg[1])) { let message = arg.slice(2).join(" ") || ''; await mentionLib.addOrUpdateDataInMention(arg[0], arg[1], message); await mentionLib.modifierStatusId1("oui"); repondre("mention updated"); } else repondre("Follow syntax: mention link type message"); } else if (arg.length === 1 && arg[0] == "stop") { await mentionLib.modifierStatusId1("non"); repondre("mention stopped"); } else repondre("Please make sure to follow the instructions"); });

